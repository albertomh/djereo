{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Djereo docs djereo - a Django project template with opinionated tooling. Built on top of the pycliche template. Features Projects created using djereo include: A basic Python package and entrypoint, configured via a pyproject.toml . Dependencies managed via uv , using a uv.lock file for reproducible builds. IPython as the default shell. Simple configuration to enhance your logs with structlog . Sensible defaults to use a postgres database from the start. Ready-to-use dev tools: Django Debug Toolbar, django-browser-reload , runserver logs formatted using rich , structlog in production. Out-of-the-box unit test suite & code coverage reporting. Batteries-included pre-commit hook configuration to lint & format code, and run SAST. A justfile to enable using just as a task runner. ...and more! Optionally, for projects intended to be hosted on GitHub, also include: GitHub Actions to: Automate cutting releases via Release Please . Run pre-commit hooks and pytest as part of a Continuous Integration pipeline. A dependabot configuration to keep Python packages & GitHub Actions up to date. If djereo sounds like a good foundation for your next project, explore the full list of features or get started with the instructions on the Quickstart page . Starting a Python project? Try pycliche , the base djereo is built on, as your Python project template.","title":"Home"},{"location":"#welcome-to-the-djereo-docs","text":"djereo - a Django project template with opinionated tooling. Built on top of the pycliche template.","title":"Welcome to the Djereo docs"},{"location":"#features","text":"Projects created using djereo include: A basic Python package and entrypoint, configured via a pyproject.toml . Dependencies managed via uv , using a uv.lock file for reproducible builds. IPython as the default shell. Simple configuration to enhance your logs with structlog . Sensible defaults to use a postgres database from the start. Ready-to-use dev tools: Django Debug Toolbar, django-browser-reload , runserver logs formatted using rich , structlog in production. Out-of-the-box unit test suite & code coverage reporting. Batteries-included pre-commit hook configuration to lint & format code, and run SAST. A justfile to enable using just as a task runner. ...and more! Optionally, for projects intended to be hosted on GitHub, also include: GitHub Actions to: Automate cutting releases via Release Please . Run pre-commit hooks and pytest as part of a Continuous Integration pipeline. A dependabot configuration to keep Python packages & GitHub Actions up to date. If djereo sounds like a good foundation for your next project, explore the full list of features or get started with the instructions on the Quickstart page . Starting a Python project? Try pycliche , the base djereo is built on, as your Python project template.","title":"Features"},{"location":"develop/","text":"Djereo developer documentation This page covers how to Develop, Test, Document and Release changes to djereo itself. Develop djereo 's source code can be found at https://github.com/albertomh/djereo . Development prerequisites In addition to the prerequisites listed in the Quickstart you will need the following to develop djereo : pre-commit Upgrading the pycliche version djereo is built on top of the pycliche Python project template. To update djereo to a newer version of pycliche : cd ~/Projects/djereo/ uvx copier update --skip-answered --trust [--vcs-ref=<TAG>] If the --vcs-ref flag is not specified, copier will use the latest pycliche tag. Using the pycliche repo as a git remote Alternatively, since djereo was started by cloning pycliche v2.10.0, the latest changes to pycliche may be brought in as follows: # ensure pycliche exists as an upstream remote repo git remote -v # expected output: # origin git@github.com:albertomh/djereo.git (fetch) # origin git@github.com:albertomh/djereo.git (push) # upstream git@github.com:albertomh/pycliche.git (fetch) # upstream git@github.com:albertomh/pycliche.git (push) # if not present, add pycliche as a remote git remote add upstream https://github.com:albertomh/pycliche.git # fetch the latest changes from pycliche git fetch upstream # merge pycliche changes into djereo # flag necessary since the repos' histories diverged git merge --allow-unrelated-histories upstream/<branch-or-tag> # resolve conflicts manually, if any # stage resolved changes and finish the merge with git commit Git principles This repo follows trunk-based development. This means: the main branch should always be in a releasable state use short-lived feature branches Please follow the Conventional Commits guidelines when writing commit messages. commitlint is enabled as a pre-commit hook. Valid commit types are defined in .commitlintrc.ts . N.B. The phrase \"gen. project\" is used frequently in commit messages. It means \"generated project\", i.e. the repository created by invoking copier with the djereo template as documented in the Quickstart . N.B. The commit type feat(docs) (and similarly scoped feat s) may seem unconventional at first glance. This is used occasionally in djereo 's commit messages to indicate that the work relates to the documentation (eg. README.md ) included in generated projects. It is a feature of djereo which relates to documentation . Dependency management Dependencies are defined in the pyproject.toml file. uv is used to manage dependencies: # add a dependency to the project uv add some-package Updating dependencies in the template There are two places where dependencies are currently declared in the template: .pre-commit-config.yaml.jinja pyproject.toml.jinja Update git hooks in the former via: cd template/ && pre-commit autoupdate Update Python packages in the latter manually. Automated option pending on account of commands like uv lock --upgrade-package not taking kindly to Jinja templates. Generate project using development version When developing djereo it is useful to observe the outcome of generating new projects that use in-progress features. To do so: # navigate to the parent directory of your local copy of djereo cd .. # vcs-ref flag to use the latest local version of djereo instead of a tagged version uvx copier copy --vcs-ref=HEAD djereo $TEST_PROJECT_NAME Style Code style is enforced by pre-commit hooks. Linter rules are configured in the ruff tables in pyproject.toml . # before you start developing, install pre-commit hooks pre-commit install # update pre-commit hooks pre-commit autoupdate Docstrings should follow the conventions set out in the Google styleguide . Upgrade checklist Check Django releases and update the django_version question in copier.yaml . Test Run all tests using pytest with: just test Tests have marks, allowing you to run only a subset: just test -m unit # or just test -m \"not smoke\" See the tool.pytest.ini_options table in pyproject.toml for a list of all marks. Document djereo 's documentation is published as a static site generated using mkdocs . Source markdown and configuration live in the docs/ directory. The docs are styled using the readthedocs theme. To view the docs when developing locally run the recipe: # from the `docs/` directory just serve and navigate to http://127.0.0.1:8001/ . A custom GitHub action ( .github/actions/publish-docs ) builds the mkdocs site and publishes it to the gh-pages branch. Changes to this branch are automatically deployed to https://albertomh.github.io/djereo/ . Release Release Please is used to automate: Updating the changelog . Calculating the new SemVer tag based on conventional commit types. Creating a new GitHub release. Release Please is configured as a GitHub action ( release-please.yaml ). It keeps a release pull request open that is refreshed as changes are merged into main . To cut a release, simply merge the release pull request. GitHub Personal Access Token In order for Release Please to automate the above process, a GitHub Actions secret called DJEREO_RELEASE_PLEASE_TOKEN must exist in GitHub ( albertomh/djereo/settings/secrets/actions ). The contents of this secret must be a Personal Access Token (PAT) with the following permissions: contents: write pull-requests: write For more information, consult the release-please-action project ).","title":"Developer docs"},{"location":"develop/#djereo-developer-documentation","text":"This page covers how to Develop, Test, Document and Release changes to djereo itself.","title":"Djereo developer documentation"},{"location":"develop/#develop","text":"djereo 's source code can be found at https://github.com/albertomh/djereo .","title":"Develop"},{"location":"develop/#development-prerequisites","text":"In addition to the prerequisites listed in the Quickstart you will need the following to develop djereo : pre-commit","title":"Development prerequisites"},{"location":"develop/#upgrading-the-pycliche-version","text":"djereo is built on top of the pycliche Python project template. To update djereo to a newer version of pycliche : cd ~/Projects/djereo/ uvx copier update --skip-answered --trust [--vcs-ref=<TAG>] If the --vcs-ref flag is not specified, copier will use the latest pycliche tag.","title":"Upgrading the pycliche version"},{"location":"develop/#using-the-pycliche-repo-as-a-git-remote","text":"Alternatively, since djereo was started by cloning pycliche v2.10.0, the latest changes to pycliche may be brought in as follows: # ensure pycliche exists as an upstream remote repo git remote -v # expected output: # origin git@github.com:albertomh/djereo.git (fetch) # origin git@github.com:albertomh/djereo.git (push) # upstream git@github.com:albertomh/pycliche.git (fetch) # upstream git@github.com:albertomh/pycliche.git (push) # if not present, add pycliche as a remote git remote add upstream https://github.com:albertomh/pycliche.git # fetch the latest changes from pycliche git fetch upstream # merge pycliche changes into djereo # flag necessary since the repos' histories diverged git merge --allow-unrelated-histories upstream/<branch-or-tag> # resolve conflicts manually, if any # stage resolved changes and finish the merge with git commit","title":"Using the pycliche repo as a git remote"},{"location":"develop/#git-principles","text":"This repo follows trunk-based development. This means: the main branch should always be in a releasable state use short-lived feature branches Please follow the Conventional Commits guidelines when writing commit messages. commitlint is enabled as a pre-commit hook. Valid commit types are defined in .commitlintrc.ts . N.B. The phrase \"gen. project\" is used frequently in commit messages. It means \"generated project\", i.e. the repository created by invoking copier with the djereo template as documented in the Quickstart . N.B. The commit type feat(docs) (and similarly scoped feat s) may seem unconventional at first glance. This is used occasionally in djereo 's commit messages to indicate that the work relates to the documentation (eg. README.md ) included in generated projects. It is a feature of djereo which relates to documentation .","title":"Git principles"},{"location":"develop/#dependency-management","text":"Dependencies are defined in the pyproject.toml file. uv is used to manage dependencies: # add a dependency to the project uv add some-package","title":"Dependency management"},{"location":"develop/#updating-dependencies-in-the-template","text":"There are two places where dependencies are currently declared in the template: .pre-commit-config.yaml.jinja pyproject.toml.jinja Update git hooks in the former via: cd template/ && pre-commit autoupdate Update Python packages in the latter manually. Automated option pending on account of commands like uv lock --upgrade-package not taking kindly to Jinja templates.","title":"Updating dependencies in the template"},{"location":"develop/#generate-project-using-development-version","text":"When developing djereo it is useful to observe the outcome of generating new projects that use in-progress features. To do so: # navigate to the parent directory of your local copy of djereo cd .. # vcs-ref flag to use the latest local version of djereo instead of a tagged version uvx copier copy --vcs-ref=HEAD djereo $TEST_PROJECT_NAME","title":"Generate project using development version"},{"location":"develop/#style","text":"Code style is enforced by pre-commit hooks. Linter rules are configured in the ruff tables in pyproject.toml . # before you start developing, install pre-commit hooks pre-commit install # update pre-commit hooks pre-commit autoupdate Docstrings should follow the conventions set out in the Google styleguide .","title":"Style"},{"location":"develop/#upgrade-checklist","text":"Check Django releases and update the django_version question in copier.yaml .","title":"Upgrade checklist"},{"location":"develop/#test","text":"Run all tests using pytest with: just test Tests have marks, allowing you to run only a subset: just test -m unit # or just test -m \"not smoke\" See the tool.pytest.ini_options table in pyproject.toml for a list of all marks.","title":"Test"},{"location":"develop/#document","text":"djereo 's documentation is published as a static site generated using mkdocs . Source markdown and configuration live in the docs/ directory. The docs are styled using the readthedocs theme. To view the docs when developing locally run the recipe: # from the `docs/` directory just serve and navigate to http://127.0.0.1:8001/ . A custom GitHub action ( .github/actions/publish-docs ) builds the mkdocs site and publishes it to the gh-pages branch. Changes to this branch are automatically deployed to https://albertomh.github.io/djereo/ .","title":"Document"},{"location":"develop/#release","text":"Release Please is used to automate: Updating the changelog . Calculating the new SemVer tag based on conventional commit types. Creating a new GitHub release. Release Please is configured as a GitHub action ( release-please.yaml ). It keeps a release pull request open that is refreshed as changes are merged into main . To cut a release, simply merge the release pull request.","title":"Release"},{"location":"develop/#github-personal-access-token","text":"In order for Release Please to automate the above process, a GitHub Actions secret called DJEREO_RELEASE_PLEASE_TOKEN must exist in GitHub ( albertomh/djereo/settings/secrets/actions ). The contents of this secret must be a Personal Access Token (PAT) with the following permissions: contents: write pull-requests: write For more information, consult the release-please-action project ).","title":"GitHub Personal Access Token"},{"location":"featurelist/","text":"Djereo's features djereo is a Django project template with opinionated tooling. When invoked by following the instructions in the Quickstart the user is prompted to answer questions and make choices via a CLI. These answers are used to create a ready-to-use opinionated Django project. This page documents the features of a Django project as generated by djereo . Setup questionnaire copier.yaml defines the questionnaire that copier will use to prompt the user when setting up a new project. The questions defined in this file include sensible defaults (where appropriate) and validation rules to prevent incoherent answers. Versions Users are asked three version-related questions when initialising a project: Django version Django is a popular web framework written in Python. djereo gives you the choice between creating projects using Django versions: 5.1 (latest) 4.2 (LTS, long-term support version) See https://endoflife.date/django for more information. Python version djereo (and its base, pycliche ) support Python 3.10 and above. The user's choice is recorded in a .python-version file and in the requires-python field of pyproject.toml . See https://endoflife.date/python for more information. Postgres version djereo is configured to work with a postgres database and contains utilities and checks to help with this. See Postgres database below for more information. Note that it is trivial to switch from postgres to SQLite (a single-line change in .env.in ) if you prefer that database engine. Keeping versions consistent The django-version-checks package is used to ensure all environments (local, CI, dev, prod) use the same versions of Python & postgres. Semantic Versioning The generated project follows Semantic Versioning, with users prompted to provide an initial version at project setup. The project's version is tracked in the version field of pyproject.toml . See Release Please below for information on how this version can be used alongside Conventional Commits to automatically generate changelogs and new semver tags. See https://semver.org/ for more information. Git pre-commit hooks Every new project comes with a set of sensible pre-commit git hooks. These are defined in .pre-commit-config.yaml and include: Common core hooks such as check-merge-conflict or end-of-file-fixer . mypy to perform static type checks on Python code. asottile/pyupgrade to convert syntax when the version of Python is upgraded. astral-sh/ruff-pre-commit to lint & format Python code at lightspeed with Ruff. Check the tool.ruff.lint table in pyproject.toml for a full list of rules and options. DavidAnson/markdownlint-cli2 to lint markdown files with rules configured in .markdownlint-cli2.yaml . biomejs/pre-commit to lint & format frontend code (JS, TS, CSS) following config in biome.jsonc . adamchainz/djade-pre-commit to format Django templates. adamchainz/django-upgrade to automatically migrate code to a new version of Django. alessandrojcm/commitlint-pre-commit-hook to enforce Conventional Commits . Optional GitHub features As part of the setup questionnaire users are asked whether the project they are creating will be hosted on GitHub. If this is the case, GitHub Actions config files are added to their project. The resulting custom actions and workflows are described below. Custom GitHub actions Three re-usable custom actions are available: pre-commit : runs all pre-commit hooks except no-commit-to-branch as this would make merge pipelines fail. In workflows (see below) all jobs depend on this action succeeding. sys-check : runs Django's system checks ( manage.py check ). test : runs all unit tests via the just test recipe (see Justfile for details). See .github/actions/ for the definitions of these actions. GitHub Actions workflows Four workflows are defined: PR (pull request) Runs whenever a pull request is opened against a branch or an existing PR receives new commits. CI (continuous integration) As with PR , but acts when a pull request is closed and changes merged into the main branch. Release Please Refreshes a pull request that updates the changelog & bumps the Semantic Version every time the main branch is merged to. .release-please-config.json configures the tool while .release-please-manifest.json is the source of truth for the latest SemVer tag. N.B. conventional commits (as enforced by the relevant git hook) are a prerequisite for Release Please to generate changelogs and calculate new SemVer tags. Dependabot Configured to update Python dependencies & GitHub actions on a weekly schedule. See .github/workflows/ and .github/dependabot.yaml for the definitions of these workflows. \ud83e\udd16 Justfile Four recipes are ready to use in every new project. Each takes care of setting up a virtualenv and installing dependencies (including the project itself in editable mode). manage : wrapper around Django's manage.py . Takes one or more arguments, which defaults to 'help'. runserver : execute Django's runserver management command using Python in Development Mode . This mode shows additional warnings (Deprecation, Import, Resource) and enables extra debug hooks. Development Mode can be disabled by passing an empty string i.e. just runserver \"\" shell : run Django's management command to drop into a shell. By default this is IPython in all new projects. test : install test dependencies, run all unit tests via Django's test runner and generate and display a coverage report (both on-screen and in HTML format). Developer Experience enhancements Use IPython as your shell IPython , an improved Python shell, is installed as a development dependency. Django picks it up by default and uses it instead of the default Python shell. Access it directly with the just shell recipe. By default IPython's debugger ( ipdb ) will launch when a breakpoint() is reached while running the application. ipdb is also used to debug tests and will launch when a test fails. The file .pdbrc contains aliases that can be used in ipdb debugger sessions. Developer tools The project comes with some ready-to-use developer tools installed as dev dependencies and configured for use locally: django-browser-reload : watch project files for changes and reload the browser. django-debug-toolbar : display information about the request/response cycle on each page. rich : nicer formatting and colours for runserver logs. Custom system checks djereo adds two custom system checks that run when the check management command is invoked. check_dev_mode : alerts to the application running in debug mode yet Python's Development Mode not being enabled, indicating that there are some warnings and debug hooks you may be missing out on. check_model_names : enforces consistent model names across the application. The sys-check GitHub action will run the default Django checks and the above custom checks as part of the continuous integration pipeline. While strictly speaking not a system test, the django-linear-migrations package is enabled on all projects generated by djereo . This package updates a max_migration.txt file whenever makemigrations runs, triggering a merge conflict if there is an attempt to apply a non-linear migration history. Use project metadata in the Django app {{project_name}}/__init__.py exposes project metadata such as version and author information. To use it in a view: from django.http import HttpResponse from {{project_name}} import __version__ def view(request): return HttpResponse(f\"on version v{__version__}\") settings.py settings.py takes values for certain configuration options from environment variables, managed via the environs package. When no values are specified, it falls back to sensible defaults. settings.py is divided into five sections: Setup Settings such as determining whether the application is running under test conditions or defining the BASE_DIR . Django Core Settings INSTALLED_APPS is defined by combining three lists containing apps according to their provenance. LOGGING is configured to use rich when DEBUG is True and structlog otherwise. Django Contrib Settings [ left empty for the user to populate ] Third Party Settings Settings for django-allauth and dev tools such as the debug toolbar and django-version-checks . Project Settings [ left empty for the user to populate ] The tool.ruff.lint.flake8-tidy-imports.banned-api table in pyproject.toml includes configuration to have the ruff pre-commit hook enforce a ban on importing the settings module directly. It suggests that you use from django.conf import settings instead as this is safer and avoids complications if override_settings is used in tests. Logging Logging differs between hosted environments (eg. production) and development. In development ( runserver ) rich is used to output coloured logs: When DEBUG=False , as in production, structlog is used instead. Logging configuration is dynamically generated based on the DEBUG environment variable. The LoggingConfigFactory class is used to generate settings for filters, formaters, handlers and loggers. Postgres database djereo projects are configured to use a postgres database out-of-the-box. This can easily be switched to use a SQLite database instead by changing a single line in the dotenv template, .env.in . Set up & tear down scripts The db/ directory contains the following database scripts: set_up.sql creates a postgres user and database with the same name as the project. tear_down.sql undoes set_up.sql and removes the database and user. Django's default test database behaviour (creating a new database with a name formed by prepending the name of the default database with test_ ) is left as-is. Database connection string The database connection is configured in settings.py using the environs package's 'Django database URL' extension. That is, as a single database connection string that is located in .env as the environment variable DATABASE_URL . seed_database management command A seed_database management command is included for quickstart purposes and as a starting point for you to populate with models needed for local development as your application grows. In a new project seed_database creates three users: admin, staff and a non-privileged regular user. Invoke it with just manage seed_database . User authentication Projects generated with djereo follow the 'custom User + UserProfile' pattern common in modern Django apps. Authentication functionality is implemented via the django-allauth package for simplicity and to ease future extensibility. A dedicated Django app, users , centralises models, template overrides and configuration for auth-related features. Third-party packages whitenoise whitenoise is included as a dependency. It is configured to serve static files using Brotli compression and add unique hashes to filenames so that each version can be cached for a long time. Tests djereo projects come with all the tooling needed to get you writing tests quickly, as well as a couple of tests ready out-of-the-box. The PendingMigrationsTests class will fail if any model changes are not yet captured in a migration, with the aim of negating the possibility of a deployment attempt that fails due to missing migrations. The test_checks module tests the custom Django system checks added by djereo . To run these tests use the recipe just test , passing the same optional arguments you would when using manage.py test e.g. just test package.module .","title":"Djereo's features"},{"location":"featurelist/#djereos-features","text":"djereo is a Django project template with opinionated tooling. When invoked by following the instructions in the Quickstart the user is prompted to answer questions and make choices via a CLI. These answers are used to create a ready-to-use opinionated Django project. This page documents the features of a Django project as generated by djereo .","title":"Djereo's features"},{"location":"featurelist/#setup-questionnaire","text":"copier.yaml defines the questionnaire that copier will use to prompt the user when setting up a new project. The questions defined in this file include sensible defaults (where appropriate) and validation rules to prevent incoherent answers.","title":"Setup questionnaire"},{"location":"featurelist/#versions","text":"Users are asked three version-related questions when initialising a project:","title":"Versions"},{"location":"featurelist/#django-version","text":"Django is a popular web framework written in Python. djereo gives you the choice between creating projects using Django versions: 5.1 (latest) 4.2 (LTS, long-term support version) See https://endoflife.date/django for more information.","title":"Django version"},{"location":"featurelist/#python-version","text":"djereo (and its base, pycliche ) support Python 3.10 and above. The user's choice is recorded in a .python-version file and in the requires-python field of pyproject.toml . See https://endoflife.date/python for more information.","title":"Python version"},{"location":"featurelist/#postgres-version","text":"djereo is configured to work with a postgres database and contains utilities and checks to help with this. See Postgres database below for more information. Note that it is trivial to switch from postgres to SQLite (a single-line change in .env.in ) if you prefer that database engine. Keeping versions consistent The django-version-checks package is used to ensure all environments (local, CI, dev, prod) use the same versions of Python & postgres.","title":"Postgres version"},{"location":"featurelist/#semantic-versioning","text":"The generated project follows Semantic Versioning, with users prompted to provide an initial version at project setup. The project's version is tracked in the version field of pyproject.toml . See Release Please below for information on how this version can be used alongside Conventional Commits to automatically generate changelogs and new semver tags. See https://semver.org/ for more information.","title":"Semantic Versioning"},{"location":"featurelist/#git-pre-commit-hooks","text":"Every new project comes with a set of sensible pre-commit git hooks. These are defined in .pre-commit-config.yaml and include: Common core hooks such as check-merge-conflict or end-of-file-fixer . mypy to perform static type checks on Python code. asottile/pyupgrade to convert syntax when the version of Python is upgraded. astral-sh/ruff-pre-commit to lint & format Python code at lightspeed with Ruff. Check the tool.ruff.lint table in pyproject.toml for a full list of rules and options. DavidAnson/markdownlint-cli2 to lint markdown files with rules configured in .markdownlint-cli2.yaml . biomejs/pre-commit to lint & format frontend code (JS, TS, CSS) following config in biome.jsonc . adamchainz/djade-pre-commit to format Django templates. adamchainz/django-upgrade to automatically migrate code to a new version of Django. alessandrojcm/commitlint-pre-commit-hook to enforce Conventional Commits .","title":"Git pre-commit hooks"},{"location":"featurelist/#optional-github-features","text":"As part of the setup questionnaire users are asked whether the project they are creating will be hosted on GitHub. If this is the case, GitHub Actions config files are added to their project. The resulting custom actions and workflows are described below.","title":"Optional GitHub features"},{"location":"featurelist/#custom-github-actions","text":"Three re-usable custom actions are available: pre-commit : runs all pre-commit hooks except no-commit-to-branch as this would make merge pipelines fail. In workflows (see below) all jobs depend on this action succeeding. sys-check : runs Django's system checks ( manage.py check ). test : runs all unit tests via the just test recipe (see Justfile for details). See .github/actions/ for the definitions of these actions.","title":"Custom GitHub actions"},{"location":"featurelist/#github-actions-workflows","text":"Four workflows are defined:","title":"GitHub Actions workflows"},{"location":"featurelist/#pr-pull-request","text":"Runs whenever a pull request is opened against a branch or an existing PR receives new commits.","title":"PR (pull request)"},{"location":"featurelist/#ci-continuous-integration","text":"As with PR , but acts when a pull request is closed and changes merged into the main branch.","title":"CI (continuous integration)"},{"location":"featurelist/#release-please","text":"Refreshes a pull request that updates the changelog & bumps the Semantic Version every time the main branch is merged to. .release-please-config.json configures the tool while .release-please-manifest.json is the source of truth for the latest SemVer tag. N.B. conventional commits (as enforced by the relevant git hook) are a prerequisite for Release Please to generate changelogs and calculate new SemVer tags.","title":"Release Please"},{"location":"featurelist/#dependabot","text":"Configured to update Python dependencies & GitHub actions on a weekly schedule. See .github/workflows/ and .github/dependabot.yaml for the definitions of these workflows.","title":"Dependabot"},{"location":"featurelist/#justfile","text":"Four recipes are ready to use in every new project. Each takes care of setting up a virtualenv and installing dependencies (including the project itself in editable mode). manage : wrapper around Django's manage.py . Takes one or more arguments, which defaults to 'help'. runserver : execute Django's runserver management command using Python in Development Mode . This mode shows additional warnings (Deprecation, Import, Resource) and enables extra debug hooks. Development Mode can be disabled by passing an empty string i.e. just runserver \"\" shell : run Django's management command to drop into a shell. By default this is IPython in all new projects. test : install test dependencies, run all unit tests via Django's test runner and generate and display a coverage report (both on-screen and in HTML format).","title":"\ud83e\udd16 Justfile"},{"location":"featurelist/#developer-experience-enhancements","text":"","title":"Developer Experience enhancements"},{"location":"featurelist/#use-ipython-as-your-shell","text":"IPython , an improved Python shell, is installed as a development dependency. Django picks it up by default and uses it instead of the default Python shell. Access it directly with the just shell recipe. By default IPython's debugger ( ipdb ) will launch when a breakpoint() is reached while running the application. ipdb is also used to debug tests and will launch when a test fails. The file .pdbrc contains aliases that can be used in ipdb debugger sessions.","title":"Use IPython as your shell"},{"location":"featurelist/#developer-tools","text":"The project comes with some ready-to-use developer tools installed as dev dependencies and configured for use locally: django-browser-reload : watch project files for changes and reload the browser. django-debug-toolbar : display information about the request/response cycle on each page. rich : nicer formatting and colours for runserver logs.","title":"Developer tools"},{"location":"featurelist/#custom-system-checks","text":"djereo adds two custom system checks that run when the check management command is invoked. check_dev_mode : alerts to the application running in debug mode yet Python's Development Mode not being enabled, indicating that there are some warnings and debug hooks you may be missing out on. check_model_names : enforces consistent model names across the application. The sys-check GitHub action will run the default Django checks and the above custom checks as part of the continuous integration pipeline. While strictly speaking not a system test, the django-linear-migrations package is enabled on all projects generated by djereo . This package updates a max_migration.txt file whenever makemigrations runs, triggering a merge conflict if there is an attempt to apply a non-linear migration history.","title":"Custom system checks"},{"location":"featurelist/#use-project-metadata-in-the-django-app","text":"{{project_name}}/__init__.py exposes project metadata such as version and author information. To use it in a view: from django.http import HttpResponse from {{project_name}} import __version__ def view(request): return HttpResponse(f\"on version v{__version__}\")","title":"Use project metadata in the Django app"},{"location":"featurelist/#settingspy","text":"settings.py takes values for certain configuration options from environment variables, managed via the environs package. When no values are specified, it falls back to sensible defaults. settings.py is divided into five sections: Setup Settings such as determining whether the application is running under test conditions or defining the BASE_DIR . Django Core Settings INSTALLED_APPS is defined by combining three lists containing apps according to their provenance. LOGGING is configured to use rich when DEBUG is True and structlog otherwise. Django Contrib Settings [ left empty for the user to populate ] Third Party Settings Settings for django-allauth and dev tools such as the debug toolbar and django-version-checks . Project Settings [ left empty for the user to populate ] The tool.ruff.lint.flake8-tidy-imports.banned-api table in pyproject.toml includes configuration to have the ruff pre-commit hook enforce a ban on importing the settings module directly. It suggests that you use from django.conf import settings instead as this is safer and avoids complications if override_settings is used in tests.","title":"settings.py"},{"location":"featurelist/#logging","text":"Logging differs between hosted environments (eg. production) and development. In development ( runserver ) rich is used to output coloured logs: When DEBUG=False , as in production, structlog is used instead. Logging configuration is dynamically generated based on the DEBUG environment variable. The LoggingConfigFactory class is used to generate settings for filters, formaters, handlers and loggers.","title":"Logging"},{"location":"featurelist/#postgres-database","text":"djereo projects are configured to use a postgres database out-of-the-box. This can easily be switched to use a SQLite database instead by changing a single line in the dotenv template, .env.in .","title":"Postgres database"},{"location":"featurelist/#set-up-tear-down-scripts","text":"The db/ directory contains the following database scripts: set_up.sql creates a postgres user and database with the same name as the project. tear_down.sql undoes set_up.sql and removes the database and user. Django's default test database behaviour (creating a new database with a name formed by prepending the name of the default database with test_ ) is left as-is.","title":"Set up &amp; tear down scripts"},{"location":"featurelist/#database-connection-string","text":"The database connection is configured in settings.py using the environs package's 'Django database URL' extension. That is, as a single database connection string that is located in .env as the environment variable DATABASE_URL .","title":"Database connection string"},{"location":"featurelist/#seed_database-management-command","text":"A seed_database management command is included for quickstart purposes and as a starting point for you to populate with models needed for local development as your application grows. In a new project seed_database creates three users: admin, staff and a non-privileged regular user. Invoke it with just manage seed_database .","title":"seed_database management command"},{"location":"featurelist/#user-authentication","text":"Projects generated with djereo follow the 'custom User + UserProfile' pattern common in modern Django apps. Authentication functionality is implemented via the django-allauth package for simplicity and to ease future extensibility. A dedicated Django app, users , centralises models, template overrides and configuration for auth-related features.","title":"User authentication"},{"location":"featurelist/#third-party-packages","text":"","title":"Third-party packages"},{"location":"featurelist/#whitenoise","text":"whitenoise is included as a dependency. It is configured to serve static files using Brotli compression and add unique hashes to filenames so that each version can be cached for a long time.","title":"whitenoise"},{"location":"featurelist/#tests","text":"djereo projects come with all the tooling needed to get you writing tests quickly, as well as a couple of tests ready out-of-the-box. The PendingMigrationsTests class will fail if any model changes are not yet captured in a migration, with the aim of negating the possibility of a deployment attempt that fails due to missing migrations. The test_checks module tests the custom Django system checks added by djereo . To run these tests use the recipe just test , passing the same optional arguments you would when using manage.py test e.g. just test package.module .","title":"Tests"},{"location":"quickstart/","text":"Quickstart This section covers how to create a Django project using djereo as a template. Prerequisites The following must be available locally: Python 3.10 or above Postgres uv just Bootstrap a new Django project Navigate to the directory under which you wish to create a new project. Run uvx copier copy --trust gh:albertomh/djereo <project_name> and follow the wizard. This creates a directory under your current location. Follow the README in the new <project_name>/ directory to get started with your project. Please note: it is not necessary to clone djereo . The gh:albertomh/djereo argument will pull the latest tag from GitHub. the --trust flag is necessary to allow a post-creation task to initialise the new directory as a git repository and generate a uv lockfile. Update existing projects To update a project created using an older version of djereo to a newer version of the template: cd ~/Projects/existing_project/ uvx copier update --skip-answered --trust [--vcs-ref=<TAG>] If the --vcs-ref flag is not specified copier will use the latest djereo tag.","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"This section covers how to create a Django project using djereo as a template.","title":"Quickstart"},{"location":"quickstart/#prerequisites","text":"The following must be available locally: Python 3.10 or above Postgres uv just","title":"Prerequisites"},{"location":"quickstart/#bootstrap-a-new-django-project","text":"Navigate to the directory under which you wish to create a new project. Run uvx copier copy --trust gh:albertomh/djereo <project_name> and follow the wizard. This creates a directory under your current location. Follow the README in the new <project_name>/ directory to get started with your project. Please note: it is not necessary to clone djereo . The gh:albertomh/djereo argument will pull the latest tag from GitHub. the --trust flag is necessary to allow a post-creation task to initialise the new directory as a git repository and generate a uv lockfile.","title":"Bootstrap a new Django project"},{"location":"quickstart/#update-existing-projects","text":"To update a project created using an older version of djereo to a newer version of the template: cd ~/Projects/existing_project/ uvx copier update --skip-answered --trust [--vcs-ref=<TAG>] If the --vcs-ref flag is not specified copier will use the latest djereo tag.","title":"Update existing projects"}]}